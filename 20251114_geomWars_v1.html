<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Asteroids-Style Top-Down Shooter</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:monospace}
  canvas{display:block;background:#000;width:100%;height:100%}
  .hint{position:fixed;left:12px;bottom:12px;color:#9ca3af;font-size:12px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hint">WASD to move • Mouse to aim • Left click to shoot • Pick powerups • R to restart</div>
<script>
// Asteroids-style top-down shooter (with powerups)
// - Bomb powerups (area-kill on pickup)
// - Weapon powerups (multi-shot, pierce, range)
// - Player acceleration, invulnerability blink, wrapping
// - Enemies steer toward player with limited turn rate

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let width = 800, height = 600;
  function resize(){
    const dpr = window.devicePixelRatio || 1;
    width = Math.max(300, innerWidth);
    height = Math.max(200, innerHeight);
    canvas.width = Math.floor(width * dpr);
    canvas.height = Math.floor(height * dpr);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Utilities
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function length(x,y){return Math.hypot(x,y)}
  function norm(x,y){const L=length(x,y)||1;return {x:x/L,y:y/L}};
  function angDiff(a,b){let d=b-a;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d}

  // Input
  const keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

  const mouse = {x: width/2, y: height/2, down:false};
  canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; });
  canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down = true; });
  window.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down = false; });

  // Game state
  let lastTime = performance.now();
  let running = true;
  let score = 0;
  let lives = 3;
  let nextExtraLife = 1000;

  // Player
  class Player{
    constructor(){
      this.x = width/2; this.y = height/2; this.radius = 14;
      this.vx = 0; this.vy = 0; this.maxSpeed = 260; this.accel = 1400; this.friction = 6;
      this.fireCooldown = 0; this.fireRate = 0.12;
      this.invulnerable = 0; this.blinkFreq = 8;
      // weapon state
      this.weapon = { bulletsPerShot:1, spread:0, pierce:1, range:1.0, timer:0 };
    }
    update(dt){
      let dx=0, dy=0;
      if(keys['w']||keys['arrowup']) dy-=1; if(keys['s']||keys['arrowdown']) dy+=1;
      if(keys['a']||keys['arrowleft']) dx-=1; if(keys['d']||keys['arrowright']) dx+=1;
      if(dx||dy){ const n=Math.hypot(dx,dy)||1; dx/=n; dy/=n; this.vx += dx*this.accel*dt; this.vy += dy*this.accel*dt; }
      else { const decel = this.friction * this.accel * dt * 0.001; const ratio = Math.max(0,1-decel); this.vx *= ratio; this.vy *= ratio; if(Math.hypot(this.vx,this.vy)<4){this.vx=0;this.vy=0;} }
      const spd = Math.hypot(this.vx,this.vy); if(spd>this.maxSpeed){ const f=this.maxSpeed/spd; this.vx*=f;this.vy*=f; }
      this.x += this.vx*dt; this.y += this.vy*dt;
      const r=this.radius; if(this.x < -r) this.x = width + r; if(this.x > width + r) this.x = -r; if(this.y < -r) this.y = height + r; if(this.y > height + r) this.y = -r;
      this.fireCooldown -= dt; if(mouse.down && this.fireCooldown<=0){ this.fireCooldown = this.fireRate; this.fire(); }
      if(this.invulnerable>0) this.invulnerable = Math.max(0,this.invulnerable - dt);
      // weapon timer
      if(this.weapon.timer>0){ this.weapon.timer = Math.max(0, this.weapon.timer - dt); if(this.weapon.timer===0){ this.weapon = defaultWeapon(); }}
    }
    fire(){
      const w = this.weapon;
      const baseAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
      const shots = w.bulletsPerShot;
      for(let i=0;i<shots;i++){
        const t = shots===1?0: (i/(shots-1) - 0.5) * w.spread; // symmetric spread
        const ang = baseAngle + t;
        const dir = {x:Math.cos(ang), y:Math.sin(ang)};
        bullets.push({x:this.x + dir.x*16, y:this.y + dir.y*16, vx:dir.x*700, vy:dir.y*700, life:w.range, pierce:w.pierce});
      }
    }
    isVisible(){ if(this.invulnerable<=0) return true; const elapsed = 2 - this.invulnerable; const phase = Math.floor(elapsed * this.blinkFreq) % 2; return phase===0; }
    draw(){ if(!this.isVisible()) return; const ang = Math.atan2(mouse.y - this.y, mouse.x - this.x); ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(ang); ctx.lineWidth=1.2; ctx.strokeStyle='#fff'; ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-10,8); ctx.lineTo(-6,0); ctx.lineTo(-10,-8); ctx.closePath(); ctx.stroke(); ctx.restore(); }
  }

  function defaultWeapon(){ return { bulletsPerShot:1, spread:0, pierce:1, range:1.0, timer:0 }; }
  const bullets = [];
  function shootBullet(sx, sy, tx, ty){ const dir = norm(tx-sx, ty-sy); bullets.push({x:sx+dir.x*16, y:sy+dir.y*16, vx:dir.x*700, vy:dir.y*700, life:1.0, pierce:1}); }

  // Enemies
  const enemies = [];
  class Enemy{ constructor(x,y,angle,speed,turnRate){ this.x=x;this.y=y;this.angle=angle;this.speed=speed;this.turnRate=turnRate;this.radius=12; this.vx=Math.cos(angle)*speed; this.vy=Math.sin(angle)*speed; } update(dt){ const desired = Math.atan2(player.y - this.y, player.x - this.x); const diff = angDiff(this.angle, desired); const maxTurn = this.turnRate * dt; const turn = clamp(diff, -maxTurn, maxTurn); this.angle += turn; this.vx = Math.cos(this.angle)*this.speed; this.vy = Math.sin(this.angle)*this.speed; this.x += this.vx*dt; this.y += this.vy*dt; } draw(){ ctx.lineWidth=1.2; ctx.beginPath(); const cos=Math.cos(this.angle), sin=Math.sin(this.angle); const p1x=this.x+cos*10, p1y=this.y+sin*10; const p2x=this.x - sin*8, p2y=this.y + cos*8; const p3x=this.x - cos*10, p3y=this.y - sin*10; const p4x=this.x + sin*8, p4y=this.y - cos*8; ctx.moveTo(p1x,p1y); ctx.lineTo(p2x,p2y); ctx.lineTo(p3x,p3y); ctx.lineTo(p4x,p4y); ctx.closePath(); ctx.stroke(); } }

  // Powerups
  const powerups = [];
  class Powerup{ constructor(x,y,type,data){ this.x=x;this.y=y;this.type=type;this.data=data; this.radius=10; this.spawnTime=0; } draw(){ ctx.lineWidth=1.2; if(this.type==='bomb'){ // circle with cross
        ctx.beginPath(); ctx.arc(this.x,this.y,10,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x-6,this.y); ctx.lineTo(this.x+6,this.y); ctx.moveTo(this.x,this.y-6); ctx.lineTo(this.x,this.y+6); ctx.stroke();
      } else if(this.type==='weapon'){
        ctx.beginPath(); // small burst icon
        ctx.moveTo(this.x-8,this.y+6); ctx.lineTo(this.x,this.y-6); ctx.lineTo(this.x+8,this.y+6); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(this.x,this.y+6,2,0,Math.PI*2); ctx.stroke();
      } }
  }

  function spawnPowerup(){ const margin=20; const x = margin + Math.random()*(width-2*margin); const y = margin + Math.random()*(height-2*margin); if(Math.random()<0.5){ // bomb
      powerups.push(new Powerup(x,y,'bomb',{radius:120}));
    } else { // weapon
      // random weapon modifiers
      const types = ['shotgun','pierce','range']; const t = types[Math.floor(Math.random()*types.length)]; let data={}; if(t==='shotgun'){ data = {bulletsPerShot:3 + Math.floor(Math.random()*3), spread:0.3 + Math.random()*0.6, pierce:1, range:1.0}; }
      else if(t==='pierce'){ data = {bulletsPerShot:1, spread:0, pierce:1 + Math.floor(Math.random()*3), range:1.0}; }
      else { data = {bulletsPerShot:1, spread:0, pierce:1, range:1.6 + Math.random()*1.8}; }
      data.duration = 18 + Math.random()*12; powerups.push(new Powerup(x,y,'weapon',data)); }
  }

  // Spawn manager
  let elapsedSinceStart = 0; let spawnTimer = 0; const baseSpawnInterval = 1.4; let powerupTimer = 6;
  function spawnEnemy(){ const margin=40; let x,y; const side=Math.floor(Math.random()*4); switch(side){case 0: x=-margin; y=Math.random()*height; break; case 1: x=width+margin; y=Math.random()*height; break; case 2: x=Math.random()*width; y=-margin; break; default: x=Math.random()*width; y=height+margin; break; } const dir=norm(player.x-x, player.y-y); const angle=Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*0.6; const baseSpeed=70; const speed = baseSpeed + Math.random()*30 + Math.min(60, elapsedSinceStart*0.6); const turnRate = 1.2 + Math.random()*1.0; enemies.push(new Enemy(x,y,angle,speed,turnRate)); }

  function pointCircleDist(ax,ay,bx,by){return Math.hypot(ax-bx,ay-by)}
  const player = new Player();
  function endGame(){ running = false; }

  // Main loop
  function update(now){ const dt = Math.min(0.05,(now - lastTime)/1000); lastTime = now; if(running){ elapsedSinceStart += dt; const spawnInterval = Math.max(0.18, baseSpawnInterval * (1 - elapsedSinceStart/100)); spawnTimer -= dt; if(spawnTimer<=0){ spawnTimer = spawnInterval; spawnEnemy(); } powerupTimer -= dt; if(powerupTimer<=0){ powerupTimer = 6 + Math.random()*10; spawnPowerup(); }
      player.update(dt);
      // bullets
      for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life -= dt; if(b.life<=0 || b.x<-80 || b.x>width+80 || b.y<-80 || b.y>height+80){ bullets.splice(i,1); continue; } }
      // enemies
      for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.update(dt);
          if(player.invulnerable<=0 && pointCircleDist(e.x,e.y,player.x,player.y) < (e.radius + player.radius - 6)){
            enemies.splice(i,1); lives -= 1; player.invulnerable = 2.0; if(lives<=0){ endGame(); } continue; }
          // bullet collisions
          let killed=false;
          for(let j=bullets.length-1;j>=0;j--){ const b=bullets[j]; if(pointCircleDist(e.x,e.y,b.x,b.y) < e.radius + 2){ // hit
                // handle piercing
                b.pierce = (b.pierce||1) - 1; if(b.pierce<=0){ bullets.splice(j,1); }
                enemies.splice(i,1); score += 10; if(score >= nextExtraLife){ lives += 1; nextExtraLife += 1000; } killed=true; break; } }
          if(killed) continue; if(e.x < -200 || e.x > width + 200 || e.y < -200 || e.y > height + 200){ enemies.splice(i,1); }
      }
      // powerups pickup
      for(let i=powerups.length-1;i>=0;i--){ const p=powerups[i]; if(pointCircleDist(p.x,p.y,player.x,player.y) < p.radius + player.radius - 4){
          // pickup
          if(p.type==='bomb'){
            // destroy enemies within radius
            const R = p.data.radius;
            for(let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; if(pointCircleDist(e.x,e.y,p.x,p.y) <= R){ enemies.splice(j,1); score += 10; if(score >= nextExtraLife){ lives += 1; nextExtraLife += 1000; } } }
          } else if(p.type==='weapon'){
            // replace weapon
            player.weapon = { bulletsPerShot:p.data.bulletsPerShot, spread:p.data.spread, pierce:p.data.pierce, range:p.data.range, timer:p.data.duration };
          }
          powerups.splice(i,1);
        } }
    }
    draw(); if(running) requestAnimationFrame(update);
  }

  function draw(){ ctx.fillStyle='#000'; ctx.fillRect(0,0,width,height); ctx.strokeStyle='#fff'; ctx.lineWidth=1.2; ctx.lineJoin='round'; ctx.lineCap='round'; player.draw(); for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,2.2,0,Math.PI*2); ctx.stroke(); }
    for(const e of enemies) e.draw(); for(const p of powerups) p.draw(); // HUD
    ctx.save(); ctx.font='14px monospace'; ctx.fillStyle='#fff'; ctx.textBaseline='top'; ctx.fillText('Score: ' + score,12,12); ctx.fillText('Lives: ' + lives,12,32);
    // weapon indicator
    const w = player.weapon; if(w.timer>0){ ctx.fillText('WEAPON: ' + w.bulletsPerShot + 'x ' + (w.pierce>1?('pierce' + w.pierce):'') + (w.range>1?' range':'') , 12, 52); ctx.fillText('Time: ' + Math.ceil(w.timer) + 's', 12, 72); } else { ctx.fillText('WEAPON: NORMAL', 12, 52); }
    ctx.restore(); if(!running){ ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,width,height); ctx.translate(width/2,height/2); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.textAlign='center'; ctx.font='36px monospace'; ctx.fillStyle='#fff'; ctx.fillText('GAME OVER',0,-28); ctx.font='20px monospace'; ctx.fillText('FINAL SCORE: ' + score,0,6); ctx.fillText('Press R to restart',0,36); ctx.restore(); } }

  // Restart
  window.addEventListener('keydown', e=>{ if(!running && (e.key.toLowerCase()==='r')){ score=0; lives=3; nextExtraLife=1000; elapsedSinceStart=0; enemies.length=0; bullets.length=0; powerups.length=0; player.x=width/2; player.y=height/2; player.vx=0; player.vy=0; player.invulnerable=0; player.weapon=defaultWeapon(); running=true; lastTime=performance.now(); requestAnimationFrame(update); } });

  // init weapon
  player.weapon = defaultWeapon();
  // start
  requestAnimationFrame(update);
})();
</script>
</body>
</html>