<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro Vector Tilt Path Game</title>
<style>
  html,body{
    margin:0;
    background:#000;
    color:#0f0;
    font-family: monospace;
    height:100%;
    overflow:hidden;
  }

  canvas{
    display:block;
    width:100vw;
    height:100vh;
    background:#000;
  }

  .ui {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 8px 12px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:14px;
  }

  button{
    background:transparent;
    color:#0f0;
    border:1px solid #0f0;
    padding:6px 10px;
    border-radius:6px;
    font-family: monospace;
  }

  #startBtn{
    position: fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    padding:14px 20px;
    background:#111;
    border:1px solid #0f0;
  }

  #endPanel{
    position: fixed;
    bottom:70px;
    left:50%;
    transform:translateX(-50%);
    padding:12px;
    border:1px solid #0f0;
    background:rgba(0,0,0,0.7);
    display:none;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<button id="startBtn">START</button>

<div class="ui">
  <div><button id="debugToggle">Debug: ON</button></div>
  <div id="counter">Mazes Completed: 0</div>
  <div id="debugInfo"></div>
</div>

<div id="endPanel">
  <div id="endText">Out of bounds</div>
  <button id="restartBtn">Restart</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W,H,cellSize;
const GRID = 9;
let corridorWidth;
let ball = {x:0,y:0,vx:0,vy:0,r:0};
let path=[], pathPoints=[];
let tiltX=0, tiltY=0;
let completed=0;
let running=false;
let debugOn=true;

function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cellSize = Math.min(W,H)/GRID;
  corridorWidth = cellSize * 0.85;
  ball.r = cellSize * 0.3;
}
resize();
window.onresize = resize;

function generatePath(){
  path=[];
  let x=0,y=0;
  path.push({x,y});
  while(x<GRID-1||y<GRID-1){
    if(Math.random()<0.5 && x<GRID-1) x++;
    else if(y<GRID-1) y++;
    path.push({x,y});
  }
  pathPoints = path.map(c=>({
    x:c.x*cellSize+cellSize/2,
    y:c.y*cellSize+cellSize/2
  }));
  ball.x = pathPoints[0].x;
  ball.y = pathPoints[0].y;
  ball.vx=ball.vy=0;
}

function distToSegment(px,py,ax,ay,bx,by){
  const vx=bx-ax, vy=by-ay;
  const wx=px-ax, wy=py-ay;
  const c1=vx*wx+vy*wy;
  if(c1<=0) return Math.hypot(px-ax,py-ay);
  const c2=vx*vx+vy*vy;
  if(c2<=c1) return Math.hypot(px-bx,py-by);
  const t=c1/c2;
  return Math.hypot(px-(ax+t*vx), py-(ay+t*vy));
}

function isOnPath(){
  const limit=corridorWidth/2;
  for(let i=0;i<pathPoints.length-1;i++){
    const a=pathPoints[i], b=pathPoints[i+1];
    if(distToSegment(ball.x,ball.y,a.x,a.y,b.x,b.y)<=limit) return true;
  }
  return false;
}

function update(){
  ball.vx += tiltX*2;
  ball.vy += tiltY*2;
  ball.vx*=0.9;
  ball.vy*=0.9;
  ball.x+=ball.vx;
  ball.y+=ball.vy;

  if(!isOnPath()){
    running=false;
    document.getElementById('endPanel').style.display='block';
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // DARK GRAY PATH FILL
  ctx.strokeStyle = "#333";
  ctx.lineWidth = corridorWidth;
  ctx.lineCap="round";
  ctx.beginPath();
  pathPoints.forEach((p,i)=>{
    if(i===0) ctx.moveTo(p.x,p.y);
    else ctx.lineTo(p.x,p.y);
  });
  ctx.stroke();

  // GREEN VECTOR OUTLINES
  ctx.strokeStyle="#0f0";
  ctx.lineWidth=2;
  ctx.beginPath();
  pathPoints.forEach((p,i)=>{
    if(i===0) ctx.moveTo(p.x,p.y);
    else ctx.lineTo(p.x,p.y);
  });
  ctx.stroke();

  // BALL OUTLINE
  ctx.strokeStyle="#fff";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.stroke();

  if(debugOn){
    document.getElementById('debugInfo').textContent =
      `tiltX:${tiltX.toFixed(2)} tiltY:${tiltY.toFixed(2)}`;
  }
}

function loop(){
  if(!running) return;
  update();
  draw();
  requestAnimationFrame(loop);
}

function startGame(){
  window.addEventListener("deviceorientation", e=>{
    tiltX = (e.gamma||0)/45;
    tiltY = (e.beta||0)/45;
  });
  generatePath();
  running=true;
  loop();
  document.getElementById('startBtn').style.display='none';
}

document.getElementById('startBtn').onclick=startGame;
document.getElementById('restartBtn').onclick=()=>{
  document.getElementById('endPanel').style.display='none';
  generatePath();
  running=true;
  loop();
};
document.getElementById('debugToggle').onclick=()=>{
  debugOn=!debugOn;
};
</script>
</body>
</html>
