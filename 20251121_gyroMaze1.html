<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Retro Tilt Path Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: black;
    font-family: monospace;
  }
  #gameCanvas {
    display: block;
    background-color: black;
  }
  #counter {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #0f0;
    font-size: 1.5em;
  }
  #endScreen {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #0f0;
    font-size: 2em;
    text-align: center;
    display: none;
  }
  #endScreen button {
    margin-top: 20px;
    padding: 10px 15px;
    font-size: 1em;
    border: none;
    border-radius: 5px;
    background-color: #0f62fe;
    color: white;
    cursor: pointer;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="counter">Mazes Completed: 0</div>
<div id="endScreen">
  <div id="scoreText">Mazes Completed: 0</div>
  <button id="restartBtn">Restart</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const counter = document.getElementById('counter');
const endScreen = document.getElementById('endScreen');
const scoreText = document.getElementById('scoreText');
const restartBtn = document.getElementById('restartBtn');

let tiltX = 0;
let tiltY = 0;

const gridSize = 9;
let cellSize;
let ballSize;
let ball = {x:0, y:0, vx:0, vy:0};
let path = [];
let pathSegments = [];
let completedMazes = 0;

// Resize canvas
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cellSize = Math.min(canvas.width, canvas.height)/gridSize;
  ballSize = cellSize*0.6;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Device tilt
function handleOrientation(event){
  tiltX = event.gamma/90;
  tiltY = event.beta/90;
}
window.addEventListener('deviceorientation', handleOrientation);

// Generate path
function generatePath(){
  path = [];
  let x=0, y=0;
  path.push({x,y});
  while(x<gridSize-1 || y<gridSize-1){
    const moves = [];
    if(x<gridSize-1) moves.push({x:x+1,y});
    if(y<gridSize-1) moves.push({x,y:y+1});
    const move = moves[Math.floor(Math.random()*moves.length)];
    path.push(move);
    x = move.x;
    y = move.y;
  }
  ball.x = path[0].x*cellSize + cellSize/2;
  ball.y = path[0].y*cellSize + cellSize/2;
  ball.vx = 0; ball.vy = 0;
  buildPathSegments();
}

// Convert path to corridor segments
function buildPathSegments(){
  pathSegments = [];
  const corridorWidth = cellSize;
  for(let i=0;i<path.length-1;i++){
    const a = path[i];
    const b = path[i+1];
    if(a.x === b.x){ // vertical
      const x = a.x*cellSize + (cellSize-corridorWidth)/2;
      const y = Math.min(a.y,b.y)*cellSize;
      const height = Math.abs(a.y-b.y+1)*cellSize;
      pathSegments.push({x,y,width:corridorWidth,height});
    } else { // horizontal
      const x = Math.min(a.x,b.x)*cellSize;
      const y = a.y*cellSize + (cellSize-corridorWidth)/2;
      const width = Math.abs(a.x-b.x+1)*cellSize;
      pathSegments.push({x,y,width,height:corridorWidth});
    }
  }
}

// Check if ball is on path
function isOnPath(ball){
  for(const seg of pathSegments){
    if(ball.x+ballSize/2 > seg.x &&
       ball.x-ballSize/2 < seg.x+seg.width &&
       ball.y+ballSize/2 > seg.y &&
       ball.y-ballSize/2 < seg.y+seg.height) return true;
  }
  return false;
}

// End game
function endGame(){
  endScreen.style.display = 'block';
  scoreText.innerText = `Mazes Completed: ${completedMazes}`;
  ball.vx = 0; ball.vy = 0;
}

// Update
function update(){
  ball.vx += tiltX*2.5;
  ball.vy += tiltY*2.5;
  const maxSpeed = cellSize*0.3;
  ball.vx = Math.max(-maxSpeed,Math.min(maxSpeed,ball.vx));
  ball.vy = Math.max(-maxSpeed,Math.min(maxSpeed,ball.vy));
  ball.x += ball.vx; ball.y += ball.vy;
  ball.vx *= 0.85; ball.vy *= 0.85;

  if(!isOnPath(ball)) endGame();

  const finish = path[path.length-1];
  const fx = finish.x*cellSize + cellSize/2;
  const fy = finish.y*cellSize + cellSize/2;
  const dx = ball.x - fx; const dy = ball.y - fy;
  if(Math.sqrt(dx*dx + dy*dy) < ballSize/2){
    completedMazes++;
    counter.innerText = `Mazes Completed: ${completedMazes}`;
    generatePath();
  }
}

// Draw retro vector style
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw path corridor
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(const seg of pathSegments){
    ctx.moveTo(seg.x, seg.y);
    ctx.lineTo(seg.x+seg.width, seg.y);
    ctx.lineTo(seg.x+seg.width, seg.y+seg.height);
    ctx.lineTo(seg.x, seg.y+seg.height);
    ctx.closePath();
  }
  ctx.stroke();

  // Draw finish point
  const finish = path[path.length-1];
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.arc(finish.x*cellSize + cellSize/2, finish.y*cellSize + cellSize/2, ballSize/2, 0, Math.PI*2);
  ctx.fill();

  // Draw ball
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ballSize/2,0,Math.PI*2);
  ctx.fill();
}

// Game loop
function gameLoop(){
  if(endScreen.style.display === 'none'){
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }
}

// Restart button
restartBtn.addEventListener('click', ()=>{
  completedMazes = 0;
  counter.innerText = `Mazes Completed: ${completedMazes}`;
  endScreen.style.display = 'none';
  generatePath();
  gameLoop();
});

// Start
generatePath();
gameLoop();
</script>
</body>
</html>
