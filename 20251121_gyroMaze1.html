<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Retro Tilt Path Game</title>
<style>
html, body {
  margin:0; padding:0; overflow:hidden; background:black; font-family: monospace;
}
#gameCanvas { display:block; background:black; }
#counter { position:absolute; top:10px; left:10px; color:#0f0; font-size:1.5em; }
#endScreen {
  position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
  color:#0f0; font-size:2em; text-align:center; display:none;
}
#endScreen button {
  margin-top:20px; padding:10px 15px; font-size:1em;
  border:none; border-radius:5px; background:#0f62fe; color:white; cursor:pointer;
}
#debugToggle {
  position:absolute; top:50px; left:10px; color:#0f0; cursor:pointer; font-size:1em;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="counter">Mazes Completed: 0</div>
<div id="debugToggle">Toggle Debug: D</div>
<div id="endScreen">
  <div id="scoreText">Mazes Completed: 0</div>
  <button id="restartBtn">Restart</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const counter = document.getElementById('counter');
const endScreen = document.getElementById('endScreen');
const scoreText = document.getElementById('scoreText');
const restartBtn = document.getElementById('restartBtn');

let tiltX=0, tiltY=0;
let debugMode = false;
const gridSize = 9;
let cellSize, ballSize;
let ball = {x:0, y:0, vx:0, vy:0};
let path = [], pathSegments = [];
let completedMazes = 0;

// Resize canvas
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cellSize = Math.min(canvas.width, canvas.height)/gridSize;
  ballSize = cellSize*0.6;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Device tilt
function handleOrientation(e){
  tiltX = e.gamma/90;
  tiltY = e.beta/90;
}
window.addEventListener('deviceorientation', handleOrientation);

// Generate random path
function generatePath(){
  path=[];
  let x=0,y=0;
  path.push({x,y});
  while(x<gridSize-1 || y<gridSize-1){
    const moves=[];
    if(x<gridSize-1) moves.push({x:x+1,y});
    if(y<gridSize-1) moves.push({x,y:y+1});
    const move = moves[Math.floor(Math.random()*moves.length)];
    path.push(move);
    x=move.x; y=move.y;
  }
  ball.x = path[0].x*cellSize+cellSize/2;
  ball.y = path[0].y*cellSize+cellSize/2;
  ball.vx=0; ball.vy=0;
  buildPathSegments();
}

// Convert path to corridor
function buildPathSegments(){
  pathSegments=[];
  const corridorWidth = cellSize;
  for(let i=0;i<path.length-1;i++){
    const a = path[i]; const b = path[i+1];
    if(a.x===b.x){ // vertical
      const x = a.x*cellSize + (cellSize-corridorWidth)/2;
      const y = Math.min(a.y,b.y)*cellSize;
      const height = Math.abs(a.y-b.y+1)*cellSize;
      pathSegments.push({x,y,width:corridorWidth,height});
    } else { // horizontal
      const x = Math.min(a.x,b.x)*cellSize;
      const y = a.y*cellSize + (cellSize-corridorWidth)/2;
      const width = Math.abs(a.x-b.x+1)*cellSize;
      pathSegments.push({x,y,width,height:corridorWidth});
    }
  }
}

// Check if ball is on path
function isOnPath(ball){
  for(const seg of pathSegments){
    if(ball.x+ballSize/2>seg.x &&
       ball.x-ballSize/2<seg.x+seg.width &&
       ball.y+ballSize/2>seg.y &&
       ball.y-ballSize/2<seg.y+seg.height) return true;
  }
  return false;
}

// End game
function endGame(){
  endScreen.style.display='block';
  scoreText.innerText=`Mazes Completed: ${completedMazes}`;
  ball.vx=0; ball.vy=0;
}

// Update ball
function update(){
  ball.vx += tiltX*2.5;
  ball.vy += tiltY*2.5;
  const maxSpeed = cellSize*0.3;
  ball.vx=Math.max(-maxSpeed,Math.min(maxSpeed,ball.vx));
  ball.vy=Math.max(-maxSpeed,Math.min(maxSpeed,ball.vy));
  ball.x += ball.vx; ball.y += ball.vy;
  ball.vx*=0.85; ball.vy*=0.85;

  if(!isOnPath(ball)) endGame();

  const finish = path[path.length-1];
  const fx = finish.x*cellSize+cellSize/2;
  const fy = finish.y*cellSize+cellSize/2;
  const dx = ball.x-fx; const dy = ball.y-fy;
  if(Math.sqrt(dx*dx+dy*dy)<ballSize/2){
    completedMazes++;
    counter.innerText = `Mazes Completed: ${completedMazes}`;
    generatePath();
  }
}

// Draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw path corridor
  ctx.fillStyle='#0f0';
  for(const seg of pathSegments){
    ctx.fillRect(seg.x,seg.y,seg.width,seg.height);
  }

  // Optional debug outlines
  if(debugMode){
    ctx.strokeStyle='#0f0';
    ctx.lineWidth=2;
    for(const seg of pathSegments){
      ctx.strokeRect(seg.x,seg.y,seg.width,seg.height);
    }
    ctx.fillStyle='yellow';
    ctx.fillText(`Ball: ${ball.x.toFixed(0)}, ${ball.y.toFixed(0)}`, 10, 70);
  }

  // Draw finish
  const finish = path[path.length-1];
  ctx.fillStyle='#0f0';
  ctx.beginPath();
  ctx.arc(finish.x*cellSize+cellSize/2, finish.y*cellSize+cellSize/2, ballSize/2,0,Math.PI*2);
  ctx.fill();

  // Draw ball
  ctx.fillStyle='#fff';
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ballSize/2,0,Math.PI*2);
  ctx.fill();
}

// Game loop
function gameLoop(){
  if(endScreen.style.display==='none'){
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }
}

// Restart button
restartBtn.addEventListener('click', ()=>{
  completedMazes=0;
  counter.innerText=`Mazes Completed: ${completedMazes}`;
  endScreen.style.display='none';
  generatePath();
  gameLoop();
});

// Debug toggle with D key
document.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='d') debugMode=!debugMode;
});

// Start
generatePath();
gameLoop();
</script>
</body>
</html>
