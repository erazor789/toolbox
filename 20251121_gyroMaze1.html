<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gyroscope Maze Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #111;
    font-family: sans-serif;
  }
  #gameCanvas {
    display: block;
    background-color: #222;
  }
  #counter {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #fff;
    font-size: 1.5em;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="counter">Wins: 0</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let tiltX = 0;
let tiltY = 0;

// Maze parameters
const gridSize = 9;
let cellSize;
let ballSize;
const walls = [];
let path = [];
let ball = {};
let winCounter = 0;

// Start and finish
let startCell = {x:0, y:0};
let finishCell = {x:gridSize-1, y:gridSize-1};

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cellSize = Math.min(canvas.width, canvas.height) / gridSize;
  ballSize = cellSize * 0.6;
}
resizeCanvas();

// Handle device orientation
function handleOrientation(event) {
  tiltX = event.gamma / 90; // left-right
  tiltY = event.beta / 90;  // front-back
}
window.addEventListener('deviceorientation', handleOrientation);

// Maze generation with guaranteed path (simple DFS)
function generateMaze() {
  walls.length = 0;
  path.length = 0;

  // Initialize grid
  const visited = Array.from({length:gridSize}, ()=>Array(gridSize).fill(false));

  function dfs(x,y) {
    visited[y][x] = true;
    path.push({x,y});
    const dirs = [[0,1],[1,0],[0,-1],[-1,0]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs) {
      const nx = x+dx;
      const ny = y+dy;
      if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && !visited[ny][nx]) {
        // Remove wall between cells by not adding it
        dfs(nx,ny);
      }
    }
  }
  dfs(startCell.x,startCell.y);

  // Build walls: for each cell, randomly place walls on edges, but never block the path
  for(let y=0; y<gridSize; y++) {
    for(let x=0; x<gridSize; x++) {
      const cellInPath = path.some(p=>p.x===x && p.y===y);
      const px = x*cellSize;
      const py = y*cellSize;

      // Random walls, but never block the path
      if(!cellInPath || Math.random()<0.3){
        // Right wall
        if(x<gridSize-1 && !path.some(p=>p.x===x+1 && p.y===y)) walls.push({x:px+cellSize, y:py, w:2, h:cellSize});
        // Bottom wall
        if(y<gridSize-1 && !path.some(p=>p.x===x && p.y===y+1)) walls.push({x:px, y:py+cellSize, w:cellSize, h:2});
      }
    }
  }

  // Outer boundaries
  walls.push({x:0,y:0,w:canvas.width,h:2});
  walls.push({x:0,y:canvas.height-2,w:canvas.width,h:2});
  walls.push({x:0,y:0,w:2,h:canvas.height});
  walls.push({x:canvas.width-2,y:0,w:2,h:canvas.height});

  // Place ball at start
  ball.x = startCell.x*cellSize + cellSize/2;
  ball.y = startCell.y*cellSize + cellSize/2;
  ball.vx = 0;
  ball.vy = 0;
}

function checkCollision(ball, rect){
  const closestX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.w));
  const closestY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.h));
  const dx = ball.x - closestX;
  const dy = ball.y - closestY;
  return dx*dx + dy*dy < (ballSize/2)*(ballSize/2);
}

function update(){
  // Apply tilt
  ball.vx += tiltX*2.5;
  ball.vy += tiltY*2.5;
  const maxSpeed = cellSize*0.3;
  ball.vx = Math.max(-maxSpeed, Math.min(maxSpeed, ball.vx));
  ball.vy = Math.max(-maxSpeed, Math.min(maxSpeed, ball.vy));
  ball.x += ball.vx;
  ball.y += ball.vy;
  ball.vx *= 0.85;
  ball.vy *= 0.85;

  // Collisions
  walls.forEach(w=>{
    if(checkCollision(ball,w)){
      if(ball.x < w.x) ball.x = w.x - ballSize/2;
      else if(ball.x > w.x + w.w) ball.x = w.x + w.w + ballSize/2;
      if(ball.y < w.y) ball.y = w.y - ballSize/2;
      else if(ball.y > w.y + w.h) ball.y = w.y + w.h + ballSize/2;
      ball.vx = 0;
      ball.vy = 0;
    }
  });

  // Check finish
  const finishX = finishCell.x*cellSize + cellSize/2;
  const finishY = finishCell.y*cellSize + cellSize/2;
  const dx = ball.x - finishX;
  const dy = ball.y - finishY;
  if(Math.sqrt(dx*dx + dy*dy) < ballSize/2){
    winCounter++;
    document.getElementById('counter').innerText = `Wins: ${winCounter}`;
    generateMaze();
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Walls
  ctx.fillStyle = '#555';
  walls.forEach(w=>ctx.fillRect(w.x,w.y,w.w,w.h));
  // Ball
  ctx.fillStyle = '#f00';
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ballSize/2,0,Math.PI*2);
  ctx.fill();
  // Finish
  ctx.fillStyle = '#0f0';
  const finishX = finishCell.x*cellSize + cellSize/2;
  const finishY = finishCell.y*cellSize + cellSize/2;
  ctx.beginPath();
  ctx.arc(finishX,finishY,ballSize/2,0,Math.PI*2);
  ctx.fill();
}

function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

window.addEventListener('resize',()=>{
  resizeCanvas();
  generateMaze();
});

generateMaze();
gameLoop();
</script>
</body>
</html>
