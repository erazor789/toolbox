<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Gyro Path Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: monospace;
      color: #00ff66;
    }
    #ui {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 14px;
      line-height: 1.4;
      pointer-events: none;
    }
    #permissionBtn {
      pointer-events: auto;
      margin-top: 6px;
      padding: 6px 10px;
      background: black;
      color: #00ff66;
      border: 1px solid #00ff66;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div>Mazes Cleared: <span id="score">0</span></div>
  <div>Tilt X: <span id="tiltX">0</span> | Tilt Y: <span id="tiltY">0</span></div>
  <div>Press D to toggle debug</div>
  <button id="permissionBtn">Enable Gyro</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const tiltXEl = document.getElementById('tiltX');
const tiltYEl = document.getElementById('tiltY');
const permissionBtn = document.getElementById('permissionBtn');

let W, H;
let score = 0;
let debug = false;
let tiltX = 0;
let tiltY = 0;

let pathPolygons = [];
let ball;
let endZone;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ---- Gyro Handling (Android Chrome compatible) ----
function handleOrientation(e) {
  tiltX = e.gamma || 0; // left/right
  tiltY = e.beta || 0;  // front/back
  tiltXEl.textContent = tiltX.toFixed(1);
  tiltYEl.textContent = tiltY.toFixed(1);
}

permissionBtn.addEventListener('click', () => {
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(resp => {
      if (resp === 'granted') window.addEventListener('deviceorientation', handleOrientation);
    });
  } else {
    window.addEventListener('deviceorientation', handleOrientation);
  }
});

// ---- Game Objects ----
function createBall() {
  return {
    r: Math.min(W, H) * 0.03,
    x: W / 2,
    y: H - 80,
    vx: 0,
    vy: 0
  };
}

function generatePath() {
  pathPolygons = [];

  const segments = 10;
  const width = W * 0.25;
  let x = W / 2;
  let y = H - 100;

  for (let i = 0; i < segments; i++) {
    let nx = x + (Math.random() * 200 - 100);
    let ny = y - (H / segments);

    pathPolygons.push([
      {x: x - width/2, y: y},
      {x: x + width/2, y: y},
      {x: nx + width/2, y: ny},
      {x: nx - width/2, y: ny}
    ]);

    x = nx;
    y = ny;
  }

  endZone = { x: x, y: y - 20, r: 30 };
}

function pointInPoly(px, py, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > py) !== (yj > py)) &&
      (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function isBallOnPath() {
  for (const poly of pathPolygons) {
    if (pointInPoly(ball.x, ball.y, poly)) return true;
  }
  return false;
}

function update() {
  const ax = tiltX * 0.05;
  const ay = tiltY * 0.05;

  ball.vx += ax;
  ball.vy += ay;
  ball.x += ball.vx;
  ball.y += ball.vy;

  if (!isBallOnPath()) {
    resetGame();
  }

  const dx = ball.x - endZone.x;
  const dy = ball.y - endZone.y;
  if (Math.sqrt(dx*dx + dy*dy) < endZone.r) {
    score++;
    scoreEl.textContent = score;
    resetGame();
  }
}

function drawPath() {
  ctx.strokeStyle = '#00ff66';
  ctx.lineWidth = 2;
  ctx.fillStyle = '#333';

  for (const poly of pathPolygons) {
    ctx.beginPath();
    ctx.moveTo(poly[0].x, poly[0].y);
    for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i].x, poly[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawBall() {
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.stroke();
}

function drawEnd() {
  ctx.strokeStyle = '#00ff66';
  ctx.beginPath();
  ctx.arc(endZone.x, endZone.y, endZone.r, 0, Math.PI * 2);
  ctx.stroke();
}

function render() {
  ctx.clearRect(0, 0, W, H);
  drawPath();
  drawEnd();
  drawBall();
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

function resetGame() {
  ball = createBall();
  generatePath();
}

window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'd') debug = !debug;
});

resetGame();
loop();
</script>
</body>
</html>
