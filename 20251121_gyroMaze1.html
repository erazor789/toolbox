<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Retro Tilt Path Game</title>
<style>
html, body {
  margin:0; padding:0; overflow:hidden; background:black; font-family: monospace;
}
#gameCanvas { display:block; background:black; }
#counter { position:absolute; top:10px; left:10px; color:#0f0; font-size:1.5em; }
#debugToggle { position:absolute; top:50px; left:10px; color:#0f0; cursor:pointer; font-size:1em; }
#endScreen {
  position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
  color:#0f0; font-size:2em; text-align:center; display:none;
}
#endScreen button {
  margin-top:20px; padding:10px 15px; font-size:1em;
  border:none; border-radius:5px; background:#0f62fe; color:white; cursor:pointer;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="counter">Mazes Completed: 0</div>
<div id="debugToggle">Toggle Debug: D</div>
<div id="endScreen">
  <div id="scoreText">Mazes Completed: 0</div>
  <button id="restartBtn">Restart</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const counter = document.getElementById('counter');
const debugToggle = document.getElementById('debugToggle');
const endScreen = document.getElementById('endScreen');
const scoreText = document.getElementById('scoreText');
const restartBtn = document.getElementById('restartBtn');

let tiltX=0, tiltY=0;
let debugMode=false;

const gridSize = 9;
let cellSize, ballSize;
let ball = {x:0, y:0, vx:0, vy:0};
let path = [], pathSegments = [];
let completedMazes = 0;

// Resize canvas
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cellSize = Math.min(canvas.width, canvas.height)/gridSize;
  ballSize = cellSize*0.6;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Device tilt
function handleOrientation(e){
  tiltX = e.gamma/90;
  tiltY = e.beta/90;
}
window.addEventListener('deviceorientation', handleOrientation);

// Generate strict horizontal/vertical path
function generatePath(){
  path = [];
  let x=0, y=0;
  path.push({x,y});
  while(x<gridSize-1 || y<gridSize-1){
    if(x<gridSize-1 && y<gridSize-1){
      if(Math.random()<0.5) x++; else y++;
    } else if(x<gridSize-1){
      x++;
    } else {
      y++;
    }
    path.push({x,y});
  }

  // Build corridor segments
  pathSegments = path.map(cell => ({
    x: cell.x*cellSize,
    y: cell.y*cellSize,
    width: cellSize,
    height: cellSize
  }));

  // Place ball in first cell
  ball.x = path[0].x*cellSize + cellSize/2;
  ball.y = path[0].y*cellSize + cellSize/2;
  ball.vx = 0; ball.vy = 0;
}

// Check if ball is on path
function isOnPath(ball){
  for(const seg of pathSegments){
    if(ball.x+ballSize/2 > seg.x &&
       ball.x-ballSize/2 < seg.x+seg.width &&
       ball.y+ballSize/2 > seg.y &&
       ball.y-ballSize/2 < seg.y+seg.height) return true;
  }
  return false;
}

// End game
function endGame(){
  endScreen.style.display='block';
  scoreText.innerText=`Mazes Completed: ${completedMazes}`;
  ball.vx=0; ball.vy=0;
}

// Update ball
function update(){
  ball.vx += tiltX*2.5;
  ball.vy += tiltY*2.5;
  const maxSpeed = cellSize*0.3;
  ball.vx = Math.max(-maxSpeed, Math.min(maxSpeed, ball.vx));
  ball.vy = Math.max(-maxSpeed, Math.min(maxSpeed, ball.vy));
  ball.x += ball.vx; ball.y += ball.vy;
  ball.vx *= 0.85; ball.vy *= 0.85;

  if(!isOnPath(ball)) endGame();

  const finish = path[path.length-1];
  const fx = finish.x*cellSize + cellSize/2;
  const fy = finish.y*cellSize + cellSize/2;
  const dx = ball.x - fx, dy = ball.y - fy;
  if(Math.sqrt(dx*dx + dy*dy) < ballSize/2){
    completedMazes++;
    counter.innerText = `Mazes Completed: ${completedMazes}`;
    generatePath();
  }
}

// Draw game
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw path corridor
  ctx.fillStyle='#0f0';
  pathSegments.forEach(seg => ctx.fillRect(seg.x, seg.y, seg.width, seg.height));

  // Optional debug outlines
  if(debugMode){
    ctx.strokeStyle='#0f0';
    ctx.lineWidth=2;
    pathSegments.forEach(seg => ctx.strokeRect(seg.x, seg.y, seg.width, seg.height));
    ctx.fillStyle='yellow';
    ctx.fillText(`Ball: ${ball.x.toFixed(0)}, ${ball.y.toFixed(0)}`, 10, 70);
  }

  // Draw finish point
  const finish = path[path.length-1];
  ctx.fillStyle='#0f0';
  ctx.beginPath();
  ctx.arc(finish.x*cellSize + cellSize/2, finish.y*cellSize + cellSize/2, ballSize/2, 0, Math.PI*2);
  ctx.fill();

  // Draw ball
  ctx.fillStyle='#fff';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ballSize/2, 0, Math.PI*2);
  ctx.fill();
}

// Game loop
function gameLoop(){
  if(endScreen.style.display==='none'){
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }
}

// Restart button
restartBtn.addEventListener('click', ()=>{
  completedMazes=0;
  counter.innerText=`Mazes Completed: ${completedMazes}`;
  endScreen.style.display='none';
  generatePath();
  gameLoop();
});

// Debug toggle via D key
document.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase()==='d') debugMode=!debugMode;
});

// Start game
generatePath();
gameLoop();
</script>
</body>
</html>
