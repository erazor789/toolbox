<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gyroscope Maze Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #111;
    font-family: sans-serif;
  }
  #gameCanvas {
    display: block;
    background-color: #222;
  }
  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2em;
    color: #0f0;
    display: none;
  }
  #restartBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 10px 15px;
    background-color: #0f62fe;
    border: none;
    color: white;
    font-size: 1em;
    border-radius: 5px;
    z-index: 10;
  }
  #timer {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 1.2em;
    color: #fff;
    z-index: 10;
  }
  #debug {
    position: absolute;
    bottom: 10px;
    left: 10px;
    font-size: 0.9em;
    color: #fff;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="message">You Win!</div>
<button id="restartBtn">Restart</button>
<div id="timer">Time: 0s</div>
<div id="debug">Tilt X: 0, Tilt Y: 0</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let startTime = Date.now();
let timerInterval;

const ball = {
  x: 50,
  y: 50,
  radius: 15,
  vx: 0,
  vy: 0,
  maxSpeed: 10
};

let tiltX = 0;
let tiltY = 0;

// Maze parameters
const maze = [];
const rows = 6;
const cols = 8;
const cellSize = Math.min(canvas.width / cols, canvas.height / rows) * 0.8;
const wallThickness = 20;

// Generate maze
function generateMaze() {
  maze.length = 0;

  // Outer walls
  maze.push({x: 0, y: 0, width: canvas.width, height: wallThickness});
  maze.push({x: 0, y: canvas.height - wallThickness, width: canvas.width, height: wallThickness});
  maze.push({x: 0, y: 0, width: wallThickness, height: canvas.height});
  maze.push({x: canvas.width - wallThickness, y: 0, width: wallThickness, height: canvas.height});

  // Random internal walls
  for(let r = 0; r < rows; r++) {
    for(let c = 0; c < cols; c++) {
      if(Math.random() < 0.3) {
        const vertical = Math.random() < 0.5;
        if(vertical) {
          maze.push({
            x: c * cellSize + wallThickness,
            y: r * cellSize,
            width: wallThickness,
            height: cellSize
          });
        } else {
          maze.push({
            x: c * cellSize,
            y: r * cellSize + wallThickness,
            width: cellSize,
            height: wallThickness
          });
        }
      }
    }
  }
}

// Finish area
const finish = {
  x: canvas.width - 70,
  y: canvas.height - 70,
  radius: 25
};

// Handle device orientation
function handleOrientation(event) {
  tiltX = event.gamma / 90; // left-right tilt
  tiltY = event.beta / 90;  // front-back
  document.getElementById('debug').innerText = `Tilt X: ${tiltX.toFixed(2)}, Tilt Y: ${tiltY.toFixed(2)}`;
}

// Android Chrome: just listen directly
window.addEventListener('deviceorientation', handleOrientation);

// Collision detection
function checkCollision(ball, rect) {
  const closestX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.width));
  const closestY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.height));
  const dx = ball.x - closestX;
  const dy = ball.y - closestY;
  return dx*dx + dy*dy < ball.radius*ball.radius;
}

// Game update
function update() {
  ball.vx += tiltX * 3; // Increased tilt sensitivity
  ball.vy += tiltY * 3;

  ball.vx = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.vx));
  ball.vy = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.vy));

  ball.x += ball.vx;
  ball.y += ball.vy;

  // Friction
  ball.vx *= 0.9;
  ball.vy *= 0.9;

  // Wall collisions
  maze.forEach(rect => {
    if(checkCollision(ball, rect)) {
      if(ball.x < rect.x) ball.x = rect.x - ball.radius;
      else if(ball.x > rect.x + rect.width) ball.x = rect.x + rect.width + ball.radius;
      if(ball.y < rect.y) ball.y = rect.y - ball.radius;
      else if(ball.y > rect.y + rect.height) ball.y = rect.y + rect.height + ball.radius;
      ball.vx = 0;
      ball.vy = 0;
    }
  });

  // Keep inside canvas
  ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
  ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));

  // Check win
  const dx = ball.x - finish.x;
  const dy = ball.y - finish.y;
  if(dx*dx + dy*dy < (ball.radius + finish.radius)**2) {
    document.getElementById('message').style.display = 'block';
    clearInterval(timerInterval);
  }
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Maze walls
  ctx.fillStyle = '#555';
  maze.forEach(rect => ctx.fillRect(rect.x, rect.y, rect.width, rect.height));

  // Finish
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.arc(finish.x, finish.y, finish.radius, 0, Math.PI*2);
  ctx.fill();

  // Ball
  ctx.fillStyle = '#f00';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
  ctx.fill();
}

// Game loop
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Timer
function startTimer() {
  startTime = Date.now();
  timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime)/1000);
    document.getElementById('timer').innerText = `Time: ${elapsed}s`;
  }, 1000);
}

// Restart button
document.getElementById('restartBtn').addEventListener('click', () => {
  ball.x = 50;
  ball.y = 50;
  ball.vx = 0;
  ball.vy = 0;
  document.getElementById('message').style.display = 'none';
  generateMaze();
  startTimer();
});

// Responsive canvas
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  generateMaze();
});

// Start game
generateMaze();
startTimer();
gameLoop();
</script>
</body>
</html>
