<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Gyro & G-Force — Ball Vector Indicator (Standalone)</title>
<style>
  :root{
    --bg:#0b0d10; --panel:#111316; --muted:#9aa4b2; --accent:#29b6f6; --warn:#ff7043;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#070809,#0c1014);color:#e6eef6;font-family:Inter,system-ui,Arial}
  .app{display:flex;flex-direction:column;min-height:100vh;padding:10px;gap:10px}
  header{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .title{font-weight:700;font-size:16px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button,select{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));border:0;color:var(--text);padding:8px 10px;border-radius:10px;font-weight:600}
  button{color:#fff}
  .btn-prim{background:#1f9bf0}
  .btn-warn{background:var(--warn)}
  .top-row{display:flex;gap:12px;align-items:center}
  main{display:grid;grid-template-columns:1fr;gap:10px;flex:1;align-content:start}
  .panel{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
  .raw-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;font-family:var(--mono);font-size:14px}
  .raw-cell{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;display:flex;justify-content:space-between;align-items:center}
  .raw-label{color:var(--muted);font-size:12px}
  .raw-value{font-size:16px;font-weight:700}
  .indicator-wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  #indicator{width:100%;max-width:360px;height:auto;background:transparent;border-radius:12px}
  .graph-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .graph-wrap{height:220px;border-radius:8px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));display:block}
  canvas.graph{width:100%;height:100%;display:block}
  footer{font-size:12px;color:var(--muted);text-align:center;padding:6px}
  .small{font-size:12px;color:var(--muted)}
  .flex{display:flex;gap:8px;align-items:center}
  .toggle{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;color:var(--accent)}
  .config{display:flex;gap:8px;align-items:center}
  @media(min-width:720px){main{grid-template-columns:420px 1fr;align-items:start} .raw-grid{grid-template-columns:repeat(2,1fr)}}
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="top-row">
        <div class="title">Gyro &amp; G-Force — Ball Vector Indicator (single file)</div>
        <div class="small">Standalone · Client-side only · Mobile-first</div>
      </div>

      <div class="controls">
        <button id="btn-perm" class="btn-prim">Enable Sensors</button>
        <button id="btn-record" class="btn-prim">Start Recording</button>
        <button id="btn-clear">Clear Data</button>
        <button id="btn-export" class="btn-warn">Export CSV</button>
        <button id="btn-full">Fullscreen</button>
      </div>
    </header>

    <main>
      <!-- LEFT: Raw + Indicator -->
      <section class="panel" id="left">
        <h3 style="margin:0 0 8px 0">Live Readouts</h3>

        <div class="raw-grid" style="margin-bottom:10px">
          <div class="raw-cell"><div><div class="raw-label">Accel X (m/s²)</div><div class="raw-value" id="acc-x">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Accel Y (m/s²)</div><div class="raw-value" id="acc-y">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Accel Z (m/s²)</div><div class="raw-value" id="acc-z">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Total G (g)</div><div class="raw-value" id="g-total">—</div></div></div>

          <div class="raw-cell"><div><div class="raw-label">Rot α (°/s)</div><div class="raw-value" id="rot-a">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Rot β (°/s)</div><div class="raw-value" id="rot-b">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Rot γ (°/s)</div><div class="raw-value" id="rot-g">—</div></div></div>
          <div class="raw-cell"><div><div class="raw-label">Hz (approx)</div><div class="raw-value" id="hz">—</div></div></div>

          <div class="raw-cell" style="grid-column:span 2"><div style="width:100%;display:flex;justify-content:space-between;align-items:center">
            <div><div class="raw-label">Orientation α/β/γ (°)</div>
              <div style="font-family:var(--mono);font-weight:700" id="orient">— / — / —</div></div>
            <div style="text-align:right">
              <div class="small">Baseline</div>
              <div id="baseline-display" class="small">0 / 0 / 0</div>
              <button id="btn-reset-baseline" class="toggle" style="margin-top:6px">Reset Orientation</button>
            </div>
          </div></div>
        </div>

        <div class="indicator-wrap">
          <h4 style="margin:0 0 6px 0">G-Force Indicator</h4>
          <canvas id="indicator" width="360" height="360" role="img" aria-label="G-force ball indicator"></canvas>

          <div class="config small" style="width:100%;max-width:360px;display:flex;gap:8px;align-items:center">
            <label>Max g:
              <select id="max-g">
                <option>1</option><option selected>2</option><option>3</option><option>5</option><option>10</option>
              </select>
            </label>
            <label>Rings:
              <select id="rings"><option>2</option><option selected>3</option><option>4</option></select>
            </label>
            <label>Trail:
              <select id="trail"><option>Off</option><option selected>Short</option><option>Long</option></select>
            </label>
            <div style="margin-left:auto" class="small">Ball size:
              <select id="ball-size"><option>6</option><option selected>10</option><option>16</option></select>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: Graphs -->
      <section class="panel" id="right">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <h3 style="margin:0">Graphs & Controls</h3>
          <div class="graph-controls">
            <button id="toggle-acc" class="toggle">Toggle Accel Graph</button>
            <button id="toggle-rot" class="toggle">Toggle Rot Graph</button>
            <label class="small">Window:
              <select id="time-window"><option value="5">5s</option><option value="10" selected>10s</option><option value="30">30s</option></select>
            </label>
          </div>
        </div>

        <div style="margin-bottom:8px">
          <div id="accel-graph" class="graph-wrap">
            <canvas id="canvas-accel" class="graph"></canvas>
          </div>
        </div>

        <div>
          <div id="rot-graph" class="graph-wrap">
            <canvas id="canvas-rot" class="graph"></canvas>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <div class="small">Recording: <strong id="rec-ind">OFF</strong></div>
          <div style="margin-left:auto" class="small">Points in buffer: <span id="buf-count">0</span></div>
        </div>
      </section>
    </main>

    <footer>
      <div class="small">Open file directly on phone. iOS: tap <strong>Enable Sensors</strong> and accept. Data stays local; export works client-side.</div>
    </footer>
  </div>

<script>
/* Single-file Gyro & G-Force Ball Vector Indicator
   - Ball moves inside circle based on X/Y acceleration magnitude
   - Concentric rings, crosshair X/Y, trail, color intensity by magnitude
   - Raw values, accel & rotation graphs, CSV export, fullscreen, baseline reset
   - All client-side, no libs
*/

/* =======================
   Utility & DOM refs
   ======================= */
const $ = id => document.getElementById(id);
const refs = {
  accX: $('acc-x'), accY: $('acc-y'), accZ: $('acc-z'),
  gTotal: $('g-total'),
  rotA: $('rot-a'), rotB: $('rot-b'), rotG: $('rot-g'),
  hz: $('hz'),
  orient: $('orient'),
  baselineDisplay: $('baseline-display'),
  btnPerm: $('btn-perm'),
  btnRecord: $('btn-record'),
  btnClear: $('btn-clear'),
  btnExport: $('btn-export'),
  btnFull: $('btn-full'),
  btnResetBaseline: $('btn-reset-baseline'),
  indicator: $('indicator'),
  maxG: $('max-g'),
  rings: $('rings'),
  trail: $('trail'),
  ballSize: $('ball-size'),
  toggleAcc: $('toggle-acc'),
  toggleRot: $('toggle-rot'),
  accelGraphWrap: $('accel-graph'),
  rotGraphWrap: $('rot-graph'),
  canvasAccel: $('canvas-accel'),
  canvasRot: $('canvas-rot'),
  timeWindowSelect: $('time-window'),
  recInd: $('rec-ind'),
  bufCount: $('buf-count'),
};

/* =======================
   State
   ======================= */
let running = false;
let recording = false;
let lastTimestamp = null;
let sampleHz = 0;
let sensorBuffer = []; // circular-ish buffer of points
const MAX_BUFFER = 20000;
let recordData = [];
let baseline = { alpha:0, beta:0, gamma:0, set:false };
let lastOrientation = null;
let meterTrail = []; // for ball trail
let meterPeak = 0;

/* Point structure:
  { t:ms, ax, ay, az, g, rAlpha, rBeta, rGamma, oAlpha, oBeta, oGamma }
*/

/* =======================
   Permission & sensors
   ======================= */
async function requestSensors(){
  try {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const res = await DeviceMotionEvent.requestPermission();
      if (res !== 'granted') throw new Error('Permission not granted');
    }
    startSensors();
    refs.btnPerm.textContent = 'Sensors Enabled';
    refs.btnPerm.disabled = true;
  } catch(err){
    alert('Sensor permission failed: ' + (err && err.message ? err.message : err));
  }
}

function startSensors(){
  if(running) return;
  window.addEventListener('devicemotion', onDeviceMotion, {passive:true});
  window.addEventListener('deviceorientation', onDeviceOrientation, {passive:true});
  running = true;
  lastTimestamp = null;
  animate();
}

function stopSensors(){
  if(!running) return;
  window.removeEventListener('devicemotion', onDeviceMotion);
  window.removeEventListener('deviceorientation', onDeviceOrientation);
  running = false;
}

/* =======================
   Sensor handlers
   ======================= */
function onDeviceMotion(e){
  const now = Date.now();
  if(lastTimestamp){
    const dt = (now - lastTimestamp)/1000;
    if(dt>0) sampleHz = Math.round(1/dt);
  }
  lastTimestamp = now;

  const a = e.acceleration || e.accelerationIncludingGravity || {x:0,y:0,z:0};
  const rot = e.rotationRate || {alpha:0,beta:0,gamma:0};

  const ax = (a.x ?? 0);
  const ay = (a.y ?? 0);
  const az = (a.z ?? 0);

  const grav = 9.80665;
  const g = Math.sqrt(ax*ax + ay*ay + az*az) / grav;

  const orient = lastOrientation || {alpha:0,beta:0,gamma:0};
  let oAlpha = orient.alpha, oBeta = orient.beta, oGamma = orient.gamma;
  if(baseline.set){ oAlpha -= baseline.alpha; oBeta -= baseline.beta; oGamma -= baseline.gamma; }

  const point = {
    t: now, ax, ay, az, g,
    rAlpha: rot.alpha ?? 0, rBeta: rot.beta ?? 0, rGamma: rot.gamma ?? 0,
    oAlpha, oBeta, oGamma
  };

  sensorBuffer.push(point);
  if(sensorBuffer.length > MAX_BUFFER) sensorBuffer.shift();
  refs.bufCount.textContent = sensorBuffer.length;

  if(recording) recordData.push(point);

  // quick raw UI update
  updateRawUI(point);
}

function onDeviceOrientation(e){
  lastOrientation = {
    alpha: e.alpha ?? 0,
    beta: e.beta ?? 0,
    gamma: e.gamma ?? 0
  };
  const a = lastOrientation.alpha - (baseline.set ? baseline.alpha : 0);
  const b = lastOrientation.beta - (baseline.set ? baseline.beta : 0);
  const g = lastOrientation.gamma - (baseline.set ? baseline.gamma : 0);
  refs.orient.textContent = `${a.toFixed(1)} / ${b.toFixed(1)} / ${g.toFixed(1)}`;
}

/* =======================
   UI updates
   ======================= */
function updateRawUI(p){
  refs.accX.textContent = p.ax.toFixed(3);
  refs.accY.textContent = p.ay.toFixed(3);
  refs.accZ.textContent = p.az.toFixed(3);
  refs.gTotal.textContent = p.g.toFixed(3) + ' g';
  refs.rotA.textContent = (p.rAlpha ?? 0).toFixed(2);
  refs.rotB.textContent = (p.rBeta ?? 0).toFixed(2);
  refs.rotG.textContent = (p.rGamma ?? 0).toFixed(2);
  refs.hz.textContent = sampleHz || '—';
}

/* =======================
   Ball indicator draw
   ======================= */
const indCanvas = refs.indicator;
const indCtx = indCanvas.getContext('2d');

function resizeIndicator(){
  const px = Math.max(1, window.devicePixelRatio || 1);
  const size = Math.min(window.innerWidth - 40, 360);
  indCanvas.width = size * px;
  indCanvas.height = size * px;
  indCanvas.style.width = size + 'px';
  indCanvas.style.height = size + 'px';
}
window.addEventListener('resize', resizeIndicator);
resizeIndicator();

function drawIndicator(){
  const c = indCanvas, ctx = indCtx;
  const px = Math.max(1, window.devicePixelRatio || 1);
  const w = c.width, h = c.height;
  ctx.clearRect(0,0,w,h);
  const cx = w/2, cy = h/2;
  const radius = Math.min(w,h)/2 - 10*px;

  // draw concentric rings
  const maxG = Number(refs.maxG.value) || 2;
  const ringCount = Math.max(1, Number(refs.rings.value) || 3);
  ctx.lineWidth = 1.5*px;
  for(let i=1;i<=ringCount;i++){
    const r = radius * (i / ringCount);
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  // crosshair lines
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1*px;
  ctx.beginPath(); ctx.moveTo(cx, cy - radius); ctx.lineTo(cx, cy + radius); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - radius, cy); ctx.lineTo(cx + radius, cy); ctx.stroke();

  // draw scale labels (0.5g steps approx)
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.font = `${12*px}px ${'monospace'}`;
  ctx.textAlign = 'center';
  for(let i=1;i<=ringCount;i++){
    const r = radius * (i / ringCount);
    const gval = (maxG * (i / ringCount)).toFixed(2) + 'g';
    ctx.fillText(gval, cx + 0, cy - r + 12*px);
  }

  // compute current vector (use last sensorBuffer point)
  const last = sensorBuffer[sensorBuffer.length-1] || {ax:0, ay:0, az:0, g:0};
  // map acceleration X/Y to display X/Y
  // Note: screen coords: right = +X, down = +Y; using ax, ay directly as visual vector
  const ax = last.ax || 0;
  const ay = last.ay || 0;
  // Magnitude in g
  const g = last.g || 0;

  // update peak
  const damping = 0.98;
  meterPeak = Math.max(meterPeak * damping, g);
  // push to trail
  const trailMode = refs.trail.value;
  if(trailMode !== 'Off'){
    const trailLen = trailMode === 'Long' ? 60 : 20;
    meterTrail.push({ax, ay, g, t:Date.now()});
    while(meterTrail.length > trailLen) meterTrail.shift();
  } else {
    meterTrail = [];
  }

  // normalize vector to display radius using maxG
  const maxGVal = Number(refs.maxG.value) || 2;
  // convert ax,ay m/s^2 to g by dividing by 9.80665
  const vx_g = ax / 9.80665;
  const vy_g = ay / 9.80665;
  let vx = vx_g, vy = vy_g;
  // clamp to maxGVal
  const mag = Math.sqrt(vx*vx + vy*vy);
  let scale = 1;
  if(mag > 0) scale = Math.min(1, (maxGVal) / mag);
  vx *= scale; vy *= scale;
  // map to pixel offset (x to right, y to up)
  const pxX = -vx * radius / maxGVal;
  const pxY = vy * radius / maxGVal;

  // draw trail (old to new)
  if(meterTrail.length){
    for(let i=0;i<meterTrail.length;i++){
      const item = meterTrail[i];
      const tscale = i / meterTrail.length;
      const tx = (item.ax / 9.80665) * radius / maxGVal;
      const ty = -(item.ay / 9.80665) * radius / maxGVal;
      ctx.beginPath();
      ctx.fillStyle = `rgba(80,160,255,${0.08 + 0.6 * tscale})`;
      ctx.arc(cx + tx, cy + ty, (2 + (refs.ballSize.value*0.08)) * px * (0.5 + tscale*0.8), 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ball color based on g magnitude
  const intensity = Math.min(1, g / maxGVal);
  const ballHue = Math.round((1 - intensity) * 200 + intensity * 10); // bluish->reddish
  const ball_alpha = 0.95;
  const ballRadius = Number(refs.ballSize.value) || 10;
  ctx.beginPath();
  ctx.fillStyle = `hsla(${ballHue},85%,55%,${ball_alpha})`;
  ctx.arc(cx + pxX, cy + pxY, ballRadius * px, 0, Math.PI*2);
  ctx.fill();

  // draw center dot
  ctx.beginPath();
  ctx.fillStyle = '#0b0d10';
  ctx.arc(cx, cy, 6 * px, 0, Math.PI*2);
  ctx.fill();

  // draw outer boundary
  ctx.lineWidth = 2*px;
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.stroke();

  // numeric overlay
  ctx.font = `${13*px}px ${'monospace'}`;
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.textAlign = 'left';
  ctx.fillText(`g: ${g.toFixed(3)}  |  x: ${vx_g.toFixed(3)}g  y: ${vy_g.toFixed(3)}g`, 12*px, 18*px);

  // peak display (small)
  ctx.textAlign = 'right';
  ctx.fillText(`peak: ${meterPeak.toFixed(3)}g`, w - 12*px, 18*px);
}

/* =======================
   Graph rendering (canvas)
   ======================= */
const aCtx = refs.canvasAccel.getContext('2d');
const rCtx = refs.canvasRot.getContext('2d');

function resizeGraphCanvases(){
  const px = Math.max(1, window.devicePixelRatio || 1);
  [ {el:refs.canvasAccel, ctx:aCtx}, {el:refs.canvasRot, ctx:rCtx} ].forEach(obj=>{
    const el = obj.el;
    const w = el.clientWidth || el.offsetWidth || 400;
    const h = el.clientHeight || 220;
    el.width = Math.max(2, w * px);
    el.height = Math.max(2, h * px);
  });
}
window.addEventListener('resize', resizeGraphCanvases);
resizeGraphCanvases();

function drawGraph(ctx, el, seriesFuncs, colors, yRange){
  const w = el.width, h = el.height;
  ctx.clearRect(0,0,w,h);

  const winSec = Number(refs.timeWindowSelect.value) || 10;
  const now = Date.now();
  const cutoff = now - winSec*1000;

  // faint center line
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1 * (window.devicePixelRatio || 1);
  ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();

  seriesFuncs.forEach((f, idx) => {
    ctx.beginPath();
    ctx.lineWidth = 2 * (window.devicePixelRatio || 1);
    ctx.strokeStyle = colors[idx];
    let started = false;
    for (let i = 0; i < sensorBuffer.length; i++){
      const p = sensorBuffer[i];
      if (p.t < cutoff) continue;
      const x = ((p.t - cutoff) / (winSec*1000)) * w;
      const val = f(p);
      const y = h - ((val - yRange.min) / (yRange.max - yRange.min)) * h;
      if (!started){ ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    }
    ctx.stroke();
  });

  // labels
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.font = `${12*(window.devicePixelRatio||1)}px ${'monospace'}`;
  ctx.textAlign = 'right';
  ctx.fillText(yRange.max.toString(), w - 6*(window.devicePixelRatio||1), 14*(window.devicePixelRatio||1));
  ctx.fillText(yRange.min.toString(), w - 6*(window.devicePixelRatio||1), h - 6*(window.devicePixelRatio||1));
}

/* =======================
   Animation loop
   ======================= */
let animating = false;
function animate(){
  if(!running) return;
  if(!animating){
    animating = true;
    (function loop(){
      if(!running){ animating = false; return; }
      resizeIndicator();
      drawIndicator();
      resizeGraphCanvases();
      if (refs.accelGraphWrap.style.display !== 'none'){
        drawGraph(aCtx, refs.canvasAccel,
          [p => p.ax, p => p.ay, p => p.az],
          ['rgba(255,80,80,0.95)','rgba(80,220,120,0.95)','rgba(80,160,255,0.95)'],
          {min:-30, max:30});
      }
      if (refs.rotGraphWrap.style.display !== 'none'){
        drawGraph(rCtx, refs.canvasRot,
          [p => p.rAlpha, p => p.rBeta, p => p.rGamma],
          ['rgba(255,160,80,0.95)','rgba(160,255,120,0.95)','rgba(120,180,255,0.95)'],
          {min:-360, max:360});
      }
      requestAnimationFrame(loop);
    })();
  }
}

/* =======================
   Controls & CSV
   ======================= */
refs.btnPerm.addEventListener('click', requestSensors);

refs.btnRecord.addEventListener('click', ()=>{
  if(!running){ alert('Enable sensors first'); return; }
  recording = !recording;
  refs.recInd.textContent = recording ? 'ON' : 'OFF';
  refs.btnRecord.textContent = recording ? 'Stop Recording' : 'Start Recording';
  if(recording) recordData = [];
});

refs.btnClear.addEventListener('click', ()=>{
  if(confirm('Clear recorded and buffered data?')){
    sensorBuffer = [];
    recordData = [];
    meterTrail = [];
    refs.bufCount.textContent = 0;
    refs.recInd.textContent = recording ? 'ON' : 'OFF';
  }
});

refs.btnExport.addEventListener('click', ()=>{
  if(recordData.length === 0){
    if(!confirm('No recorded data. Export current buffer instead?')) return;
    exportCSV(sensorBuffer);
    return;
  }
  exportCSV(recordData);
});

refs.btnFull.addEventListener('click', async ()=>{
  try{
    if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){ console.warn('Fullscreen error', e); }
});

refs.toggleAcc.addEventListener('click', ()=>{
  const el = refs.accelGraphWrap;
  el.style.display = (el.style.display === 'none') ? '' : 'none';
});
refs.toggleRot.addEventListener('click', ()=>{
  const el = refs.rotGraphWrap;
  el.style.display = (el.style.display === 'none') ? '' : 'none';
});

refs.btnResetBaseline.addEventListener('click', ()=>{
  if(!lastOrientation){ alert('Orientation not yet available. Move device a bit.'); return; }
  baseline.alpha = lastOrientation.alpha || 0;
  baseline.beta = lastOrientation.beta || 0;
  baseline.gamma = lastOrientation.gamma || 0;
  baseline.set = true;
  refs.baselineDisplay.textContent = `${baseline.alpha.toFixed(1)} / ${baseline.beta.toFixed(1)} / ${baseline.gamma.toFixed(1)}`;
});

function exportCSV(list){
  if(!list || list.length === 0){ alert('No data to export'); return; }
  const rows = [];
  rows.push(['timestamp_ms','acc_x','acc_y','acc_z','g','rot_alpha','rot_beta','rot_gamma','orient_alpha','orient_beta','orient_gamma'].join(','));
  list.forEach(p=>{
    const row = [
      p.t,
      p.ax.toFixed(6),
      p.ay.toFixed(6),
      p.az.toFixed(6),
      p.g.toFixed(6),
      (p.rAlpha ?? 0).toFixed(6),
      (p.rBeta ?? 0).toFixed(6),
      (p.rGamma ?? 0).toFixed(6),
      (p.oAlpha ?? 0).toFixed(6),
      (p.oBeta ?? 0).toFixed(6),
      (p.oGamma ?? 0).toFixed(6)
    ].join(',');
    rows.push(row);
  });
  const blob = new Blob([rows.join('\n')], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.href = url; a.download = `motion_log_${ts}.csv`; a.style.display='none';
  document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
}

/* =======================
   Init
   ======================= */
(function init(){
  if(window.DeviceMotionEvent){
    try { startSensors(); refs.btnPerm.style.display = (typeof DeviceMotionEvent.requestPermission === 'function') ? 'inline-block' : 'none'; }
    catch(e){ console.warn('startSensors fallback', e); }
  } else {
    alert('DeviceMotionEvent not supported on this device/browser.');
  }
  refs.accelGraphWrap.style.display = '';
  refs.rotGraphWrap.style.display = '';
  setTimeout(()=>{ resizeGraphCanvases(); resizeIndicator(); }, 200);
})();
</script>
</body>
</html>

