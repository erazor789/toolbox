<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FileMindMap2D â€” GitHub Pages Ready</title>
<style>
  html, body { margin: 0; padding: 0; width: 100%; height: 100%; font-family: system-ui, sans-serif; overflow: hidden; background: #111; }
  #ui { position: fixed; top: 12px; left: 12px; z-index: 10; background: rgba(0,0,0,0.65); padding: 10px 14px; border-radius: 8px; color: #fff; backdrop-filter: blur(6px); }
  #dropzone { border: 2px dashed #4dabf7; padding: 10px; cursor: pointer; width: 220px; text-align: center; margin-bottom: 6px; }
  #stats { font-size: 12px; color: #aaa; }
  canvas { display: block; }
</style>
</head>
<body>

<div id="ui">
  <div id="dropzone">Drop folder here or click to select</div>
  <input type="file" id="pick" webkitdirectory multiple style="display:none;">
  <div id="stats">No folder selected.</div>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  draw();
});

let rootNode = null;
let panX = width/2, panY = 50;
let nodeSpacingY = 50;
let nodeSpacingX = 100; // wider spacing to reduce overlap

// Drag-and-drop support
const dropzone = document.getElementById('dropzone');
const picker = document.getElementById('pick');

dropzone.addEventListener('click', () => picker.click());
dropzone.addEventListener('dragover', e => e.preventDefault());
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  const files = Array.from(e.dataTransfer.files);
  handleFiles({ target: { files } });
});

// Fallback file picker
picker.addEventListener('change', handleFiles);

function handleFiles(event) {
  const files = Array.from(event.target.files);
  if (!files.length) return;

  rootNode = { name: "Root", size: 0, children: {}, expanded: true };

  files.forEach(file => {
    const pathParts = file.webkitRelativePath ? file.webkitRelativePath.split('/') : [file.name];
    let current = rootNode;
    for (let i=0; i<pathParts.length; i++) {
      const part = pathParts[i];
      if (i === pathParts.length - 1) {
        // File node
        if (!current.children['_files']) current.children['_files'] = [];
        const size = file.size || 0;
        current.children['_files'].push({ name: part, size });
        current.size += size;
      } else {
        if (!current.children[part]) current.children[part] = { name: part, size: 0, children: {}, expanded: true };
        current = current.children[part];
      }
    }
  });

  // Compute folder sizes recursively
  function sumSizes(node) {
    if (node.children['_files']) node.children['_files'].forEach(f => node.size += f.size);
    Object.values(node.children).forEach(c => { if (c.name) node.size += sumSizes(c); });
    return node.size;
  }
  sumSizes(rootNode);

  document.getElementById('stats').innerText = `Total Size: ${(rootNode.size/1e9).toFixed(2)} GB`;

  draw();
}

// Draw mindmap recursively
function drawNode(node, x, y) {
  ctx.font = "14px sans-serif";
  const sizeText = node.size ? ` (${(node.size/1e6).toFixed(2)} MB)` : '';
  const text = node.name + sizeText;
  const textWidth = ctx.measureText(text).width;

  // Node rectangle
  ctx.fillStyle = '#222';
  ctx.fillRect(x-5, y-12, textWidth+10, 20);
  ctx.strokeStyle = '#4dabf7';
  ctx.strokeRect(x-5, y-12, textWidth+10, 20);
  ctx.fillStyle = '#fff';
  ctx.fillText(text, x, y);

  // Children
  if (!node.expanded) return;

  let children = Object.values(node.children);
  if (node.children['_files']) children = children.concat(node.children['_files']);

  let startX = x - ((children.length-1) * nodeSpacingX) / 2;

  children.forEach(child => {
    const childY = y + nodeSpacingY;
    const childX = startX;

    // Draw connecting line
    ctx.strokeStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(x, y + 5);
    ctx.lineTo(childX, childY - 12);
    ctx.stroke();

    drawNode(child, childX, childY);

    startX += nodeSpacingX;
  });
}

// Draw entire canvas
function draw() {
  ctx.clearRect(0, 0, width, height);
  if (rootNode) drawNode(rootNode, panX, panY);
}

// Click to expand/collapse
canvas.addEventListener('click', e => {
  if (!rootNode) return;
  const mx = e.offsetX, my = e.offsetY;

  function toggleNode(node, x, y) {
    ctx.font = "14px sans-serif";
    const sizeText = node.size ? ` (${(node.size/1e6).toFixed(2)} MB)` : '';
    const text = node.name + sizeText;
    const textWidth = ctx.measureText(text).width;
    const rect = {x: x-5, y: y-12, w: textWidth+10, h: 20};

    if (mx >= rect.x && mx <= rect.x+rect.w && my >= rect.y && my <= rect.y+rect.h) {
      node.expanded = !node.expanded;
      draw();
      return true;
    }

    if (node.expanded) {
      let children = Object.values(node.children);
      if (node.children['_files']) children = children.concat(node.children['_files']);

      let startX = x - ((children.length-1) * nodeSpacingX) / 2;
      for (let child of children) {
        const childY = y + nodeSpacingY;
        const childX = startX;
        if (toggleNode(child, childX, childY)) return true;
        startX += nodeSpacingX;
      }
    }
    return false;
  }

  toggleNode(rootNode, panX, panY);
});
</script>
</body>
</html>
