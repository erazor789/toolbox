<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FileMindMap2D â€” Browser 2D Mindmap</title>
<style>
  html, body { margin: 0; padding: 0; width: 100%; height: 100%; font-family: system-ui, sans-serif; overflow: hidden; background: #111; }
  #ui { position: fixed; top: 12px; left: 12px; z-index: 10; background: rgba(0,0,0,0.65); padding: 10px 14px; border-radius: 8px; color: #fff; backdrop-filter: blur(6px); }
  #pick { background: #4dabf7; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; color: white; font-weight: 600; }
  #stats { margin-top: 6px; font-size: 12px; color: #aaa; }
  canvas { display: block; }
  .node { cursor: pointer; }
</style>
</head>
<body>

<div id="ui">
  <input type="file" id="pick" webkitdirectory multiple>
  <div id="stats">No folder selected.</div>
</div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  draw();
});

// Globals
let rootNode = null;
let panX = width/2, panY = 50;
let nodeSpacingY = 50;
let nodeSpacingX = 20;

// Handle file input
document.getElementById('pick').addEventListener('change', handleFiles);

function handleFiles(event) {
  const files = Array.from(event.target.files);
  if (files.length === 0) return;

  // Build tree
  rootNode = { name: "Root", size: 0, children: {}, expanded: true };
  files.forEach(file => {
    const parts = file.webkitRelativePath.split('/');
    let current = rootNode;
    for (let i=0; i<parts.length; i++) {
      const part = parts[i];
      if (i === parts.length - 1) {
        // File
        if (!current.children['_files']) current.children['_files'] = [];
        current.children['_files'].push({ name: part, size: file.size });
        current.size += file.size;
      } else {
        if (!current.children[part]) current.children[part] = { name: part, size: 0, children: {}, expanded: true };
        current = current.children[part];
      }
    }
  });

  // Compute folder sizes recursively
  function sumSizes(node) {
    if (node.children['_files']) node.children['_files'].forEach(f => node.size += f.size);
    Object.values(node.children).forEach(c => { if (c.name) node.size += sumSizes(c); });
    return node.size;
  }
  sumSizes(rootNode);

  document.getElementById('stats').innerText = `Total Size: ${(rootNode.size/1e9).toFixed(2)} GB`;

  draw();
}

// Draw mindmap recursively
function drawNode(node, x, y, ctx) {
  ctx.fillStyle = '#4dabf7';
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.font = "14px sans-serif";

  const text = `${node.name} (${(node.size/1e6).toFixed(2)} MB)`;
  const textWidth = ctx.measureText(text).width;

  // Node rectangle
  ctx.fillStyle = '#222';
  ctx.fillRect(x - 5, y - 12, textWidth + 10, 20);
  ctx.strokeStyle = '#4dabf7';
  ctx.strokeRect(x - 5, y - 12, textWidth + 10, 20);

  ctx.fillStyle = '#fff';
  ctx.fillText(text, x, y);

  // Children
  if (!node.expanded) return;

  let childY = y + nodeSpacingY;
  let childX = x - (Object.keys(node.children).length*nodeSpacingX)/2;

  Object.values(node.children).forEach(c => {
    ctx.strokeStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(x, y + 5);
    ctx.lineTo(childX, childY - 12);
    ctx.stroke();
    drawNode(c, childX, childY, ctx);
    childX += nodeSpacingX;
  });

  if (node.children['_files']) {
    node.children['_files'].forEach(f => {
      ctx.strokeStyle = '#888';
      ctx.beginPath();
      ctx.moveTo(x, y + 5);
      ctx.lineTo(childX, childY - 12);
      ctx.stroke();
      drawNode(f, childX, childY, ctx);
      childX += nodeSpacingX;
    });
  }
}

// Main draw
function draw() {
  ctx.clearRect(0, 0, width, height);
  if (rootNode) drawNode(rootNode, panX, panY, ctx);
}

// Optional: click to expand/collapse
canvas.addEventListener('click', e => {
  if (!rootNode) return;
  const mx = e.offsetX;
  const my = e.offsetY;

  function toggleNode(node, x, y) {
    ctx.font = "14px sans-serif";
    const text = `${node.name} (${(node.size/1e6).toFixed(2)} MB)`;
    const textWidth = ctx.measureText(text).width;
    const rect = {x: x-5, y: y-12, w: textWidth+10, h: 20};

    if (mx >= rect.x && mx <= rect.x+rect.w && my >= rect.y && my <= rect.y+rect.h) {
      node.expanded = !node.expanded;
      draw();
      return true;
    }

    if (node.expanded) {
      let childY = y + nodeSpacingY;
      let childX = x - (Object.keys(node.children).length*nodeSpacingX)/2;
      for (let c of Object.values(node.children)) {
        if (toggleNode(c, childX, childY)) return true;
        childX += nodeSpacingX;
      }
      if (node.children['_files']) {
        for (let f of node.children['_files']) {
          if (toggleNode(f, childX, childY)) return true;
          childX += nodeSpacingX;
        }
      }
    }
    return false;
  }

  toggleNode(rootNode, panX, panY);
});
</script>
</body>
</html>
