<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FileMindMap2D â€” Drag & Drop Folder</title>
<style>
  html, body { margin: 0; padding: 0; width: 100%; height: 100%; font-family: system-ui, sans-serif; overflow: hidden; background: #111; }
  #ui { position: fixed; top: 12px; left: 12px; z-index: 10; background: rgba(0,0,0,0.65); padding: 10px 14px; border-radius: 8px; color: #fff; backdrop-filter: blur(6px); }
  #dropzone { border: 2px dashed #4dabf7; padding: 10px; cursor: pointer; width: 220px; text-align: center; margin-bottom: 6px; }
  #stats { font-size: 12px; color: #aaa; }
  canvas { display: block; }
</style>
</head>
<body>

<div id="ui">
  <div id="dropzone">Drop folder here or click to select</div>
  <input type="file" id="pick" webkitdirectory multiple style="display:none;">
  <div id="stats">No folder selected.</div>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  draw();
});

let rootNode = null;
let panX = width/2, panY = 50;
let nodeSpacingY = 50;
let nodeSpacingX = 20;

// Drag-and-drop support
const dropzone = document.getElementById('dropzone');
const picker = document.getElementById('pick');

dropzone.addEventListener('click', () => picker.click());
dropzone.addEventListener('dragover', e => e.preventDefault());
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  const files = Array.from(e.dataTransfer.files);
  handleFiles({ target: { files } });
});

// Fallback file picker
picker.addEventListener('change', handleFiles);

function handleFiles(event) {
  const files = Array.from(event.target.files);
  if (!files.length) return;

  rootNode = { name: "Root", size: 0, children: {}, expanded: true };

  files.forEach(file => {
    const parts = file.webkitRelativePath.split('/');
    let current = rootNode;
    for (let i=0; i<parts.length; i++) {
      const part = parts[i];
      if (i === parts.length - 1) {
        if (!current.children['_files']) current.children['_files'] = [];
        current.children['_files'].push({ name: part, size: file.size });
        current.size += file.size;
      } else {
        if (!current.children[part]) current.children[part] = { name: part, size: 0, children: {}, expanded: true };
        current = current.children[part];
      }
    }
  });

  // Compute folder sizes recursively
  function sumSizes(node) {
    if (node.children['_files']) node.children['_files'].forEach(f => node.size += f.size);
    Object.values(node.children).forEach(c => { if (c.name) node.size += sumSizes(c); });
    return node.size;
  }
  sumSizes(rootNode);

  document.getElementById('stats').innerText = `Total Size: ${(rootNode.size/1e9).toFixed(2)} GB`;

  draw();
}

// Draw mindmap
function drawNode(node, x, y) {
  ctx.font = "14px sans-serif";
  const text = `${node.name} (${(node.size/1e6).toFixed(2)} MB)`;
  const textWidth = ctx.measureText(text).width;

  // Node box
  ctx.fillStyle = '#222';
  ctx.fillRect(x-5, y-12, textWidth+10, 20);
  ctx.strokeStyle = '#4dabf7';
  ctx.strokeRect(x-5, y-12, textWidth+10, 20);
  ctx.fillStyle = '#fff';
  ctx.fillText(text, x, y);

  // Draw children
  if (!node.expanded) return;

  let childY = y + nodeSpacingY;
  let childX = x - (Object.keys(node.children).length*nodeSpacingX)/2;

  Object.values(node.children).forEach(c => {
    ctx.strokeStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(x, y + 5);
    ctx.lineTo(childX, childY - 12);
    ctx.stroke();
    drawNode(c, childX, childY);
    childX += nodeSpacingX;
  });

  if (node.children['_files']) {
    node.children['_files'].forEach(f => {
      ctx.strokeStyle = '#888';
      ctx.beginPath();
      ctx.moveTo(x, y + 5);
      ctx.lineTo(childX, childY - 12);
      ctx.stroke();
      drawNode(f, childX, childY);
      childX += nodeSpacingX;
    });
  }
}

function draw() {
  ctx.clearRect(0, 0, width, height);
  if (rootNode) drawNode(rootNode, panX, panY);
}

// Click to expand/collapse
canvas.addEventListener('click', e => {
  if (!rootNode) return;
  const mx = e.offsetX, my = e.offsetY;

  function toggleNode(node, x, y) {
    ctx.font = "14px sans-serif";
    const text = `${node.name} (${(node.size/1e6).toFixed(2)} MB)`;
    const textWidth = ctx.measureText(text).width;
    const rect = {x: x-5, y: y-12, w: textWidth+10, h: 20};

    if (mx >= rect.x && mx <= rect.x+rect.w && my >= rect.y && my <= rect.y+rect.h) {
      node.expanded = !node.expanded;
      draw();
      return true;
    }

    if (node.expanded) {
      let childY = y + nodeSpacingY;
      let childX = x - (Object.keys(node.children).length*nodeSpacingX)/2;
      for (let c of Object.values(node.children)) {
        if (toggleNode(c, childX, childY)) return true;
        childX += nodeSpacingX;
      }
      if (node.children['_files']) {
        for (let f of node.children['_files']) {
          if (toggleNode(f, childX, childY)) return true;
          childX += nodeSpacingX;
        }
      }
    }
    return false;
  }

  toggleNode(rootNode, panX, panY);
});
</script>
</body>
</html>
